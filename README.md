
# Общие сведения о реализации:

* Проект реализован в соответствии с принципами чистой архитектуры.

* Реализован менеджер транзакций, поддерживающий различные уровни изоляции транзакций. Он используется в usecase слое. Тем самым обеспечена атомарность, консистентность и изоляция транзакций. Благодаря этому, например, получились простые и переиспользуемые функции repo слоя.

* В условии была сказано, что сотрудников может быть до 100к, RPS — 1k, SLI времени ответа — 50 мс, SLI успешности ответа — 99.99%.
	* Для обеспечения этих требований реализована программная поддержка реплицирования БД. Так, на уровне бизнес логики мы можем выбрать к какому типу относится операция: read или write. Если операция read, то менеджер транзакций выполнит ее на реплике, если write, то на primary БД. При этом он обращается к провайдеру баз данных dbClient, который предоставляет функции Primary() и Replica() для получения primary и реплики соответственно. Был реализован простой сценарий, когда возвращается одна и та же БД. Однако можно сделать много реплик и выбирать например по Round Robin. Главное, что благодаря интерфейсам мы можем легко заменить один провайдер БД на другой. Репозиторий работает с интерфейсом БД (Exec, Query, ...), что так же обеспечивает гибкость.
	* Реализован повтор операций в случае ошибки с настраиваемым количеством попыток и таймаутом.

* Реализована структура, управляющая зависимостями приложения (service provider в internal/app).

* Реализован closer, который закрывает все ресурсы приложения при получении сигнала от клиента.

* Реализован graceful shutdown.

* Total test coverage: 64%

* Юнит-тестами покрыты: весь слой usecase, весь слой delivery, конвертер между сущностями БД и бизнес-логики, пакет closer.

* Написаны интеграционные тесты на сценарий получения и отправки монет, покупки товаров.

* Сервер и база данных запускаются через docker compose. При поднятии БД происходит автоматическая накатка миграций.

* Настроены конфигурация линтера, его замечания исправлялись по ходу выполнения задачи. Однако не все они были исправлены в силу ограниченности времени.

* Реализована возможность настройки приложения через конфигурационный файл, а также через переменные окружения.

* Каждый из слоев: repo, usecase, delivery работает со своими моделями данных: entity, model, DTO соответсвенно. Пользователь отправляет данные, которые преобразуются контроллером в model для usecase, при получении ответа из usecase контроллер мапит его в dto и отправляет клиенту. Слой репозитория работает исключительно с entity.

* Реализованы функции-конвертеры между сущностями контроллера (DTO) и бизнес-логики (model).

* Реализованы конвертеры между сущностями БД (entity) и бизнес-логики (model).

* Добавлена возможность автоматической генерации DTO эндпоинтов по OpenAPI спецификации (см. Makefile, make gen-dto VERSION=v1).

* Реализованы JWT-аутентификация и авторизация с использованием middleware, вшиванием claims с id пользователя в контекст. 
	* Разделение ответсвенности: middleware отвечает за аутентификацию, возвращает ошибку, если пользователь не авторизован. 
	* Если все нормально, управление передается функциям delivery слоя, которые проверяют параметры, тело запроса, и сразу возвращают ошибку клиенту, если с ними что-то не так. 
	* Бизнес-логика выполняет более сложную валидацию входных данных, которая требует обращения к БД. Например, что получатель монет с данным именем существует, что отправитель и получатель это не один и тот же человек)

* Реализованы хеширование пароля с солью для повышения безопасности. Менеджер паролей в usecase представлен интерфейсом, как и другие зависмости, так что его можно легко заменить на другой. В проекте используется bcrypt менеджер паролей, реализованный в pkg.

* Дифференцирование ошибок на всех уровнях: usecase, delivery, repo.


# Принятые решения:

1. Хоть по апи пользователь может покупать только 1 продукт, в схему purchase_operations я добавила quantity, чтобы можно было покупать несколько продуктов и не переписывать схему.

2. Схема БД построена так, что таблица operations содержит общие для всех типов финансовых операций данные, например время исполнения и пользователь ее инициировавший. А специфичные для каждой из оераций данные хранятся в соответсвующих таблицах. Так, например, операции перевода содержат в себе id получателя, а операции покупки содержат в себе id продукта, количество купленного товара и общую сумму покупки (на случай появления скидок, инвариант общая сумма = кол-во * цена продукта перестанет выполняться).

3. При работе с балансами возможна ситуация, когда он изменяется в разных транзакциях. Одной из аномалий может быть Lost Update. Решение: использование SELECT ... FOR UPDATE при запросах.

4. Если используем Serializable и происходит конкуррентное обновление, то одна из транзакций завершится с ошибкой 40001 (serialization failure). В таком случае повторяем транзакцию, которая не завершилась успешно.

5. Я не выбрала уровень изоляции serializable для получения данных о балансе, покупках, переводах ради производительности и избежания ошибки 40001. В результате жертвуем тем, что баланс может не соответствовать истории операций, если между его запросом и получением истории операции кто-то выполнит покупку или перевод, но это не выглядит критичным.

## Установка:

```git clone https://github.com/resueman/merch-store.git && cd merch-store```

## Запуск сервера и бд:

```make up``` - запуск сервера и бд

```make up-db``` - запуск бд

```make up-test-db``` - запуск тестовой бд

## Доступные таргеты в Makefile:

```make help``` - справка о доступных таргетах

## Тесты:

```make run-tests``` - запуск всех тестов

```make coverage-total``` - получение общего тестового покрытия

## Линтер:

```make install-lint``` - установка линтера

```make run-lint``` - запуск линтера

## Кодогенерация:

```make gen-api VERSION=v1``` - генерация dto и сервера версии v1  
